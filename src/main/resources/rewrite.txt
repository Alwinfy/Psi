@MOD psi
@BOOK(taurus_silver_handbook) MAP{$(piece)->$(3)} i18n:book. icon:tablet Taurus Silver's Codex; How 2 Psi. (This book is a work in progress; expect many crosslinks to be broken. I'm workin' on it.)

##basics icon:textures/spell/trick_debug.png Basics

#introduction+ Introduction
Welcome to $(thing)Psi$(0), the greatest spell-program-based magitech mod on this side of the universe!$(p)To begin your journey to become a spellslinging mage, you'll first need some $(item)Psidust$(0)-- however, one does not simply craft the stuff.$(p)Instead, start by crafting a $(item)CAD Assembler$(0) and an $(item)Iron CAD Assembly$(0).
Place the $(item)CAD Assembler$(0) and insert the $(item)Iron CAD Assembly$(0) to construct a very bare-bones $(thing)Casting Assistant Device$(0) ($(thing)CAD$(0), for short).$(p)From there, drop some $(item)Redstone Dust$(0) on the ground, point your new $(thing)CAD$(0) at the dust, and cast with it ($(k:use)) to create some $(item)Psidust$(0).

#cad_assembler icon:cad_assembler CAD Assembler
The $(item)CAD Assembler$(0) is the heart of $(thing)Psi$(0), serving two essential functions.$(p)First, it (as its name suggests) assembles a $(thing)CAD$(0) from its component parts. Second, it loads $(o)non-empty$() $(item)Spell Bullets$(0) into $(thing)CADs$(0) (as well as other things that hold $(item)Bullets$(0), such as $(item)Psimetal Tools$(0)).
@RECIPE (assembler): Build-a-CAD Workshop
@IMAGE (assembler_build): The simplest CAD that can cast
A $(thing)CAD$(0) is built from of up to five components; the simplest $(thing)CAD$(0) only uses one component, an $(thing)Assembly$(0), though this is only useful for crafting $(item)Psidust$(0).$(p)A $(thing)CAD$(0) capable of casting $(thing)Spells$(0) requires a $(thing)Core$(0) and a $(thing)Socket$(0) as well.$(p)Adding a $(thing)Battery$(0) slightly increases a user's maximum $(thing)Psi energy$(0), and adding a $(thing)Colorizer$(0) changes the color of casted $(thing)Spells$(0) (purely cosmetically).
Once a $(thing)CAD$(0) is created, it can be placed in the leftmost panel of the $(item)CAD Assembler$(0). When placed there, the slots below open; $(item)Spell Bullets$(0) can be placed in these slots to be loaded into the $(thing)CAD$(0). Once the $(item)Bullets$(0) are loaded, the $(thing)CAD$(0) is removed and in-hand, and the $(thing)Psi master keybind$(0) ($(k:psimisc.keybind)) is held, the $(item)Bullets$(0)' $(thing)Spells$(0) will be displayed on a HUD, ready to be selected and cast.
@IMAGE (assembler_load): A CAD with one bullet loaded

#spell_programmer icon:programmer Spell Programmer
If the $(item)CAD Assembler$(0) is the heart of $(thing)Psi$(0), then the $(item)Spell Programmer$(0) is the brains of the mod. It's where $(thing)Spells$(0) are written and compiled, and eventually copied into $(item)Spell Bullets$(0) to be cast.$(p)When placed and opened ($(k:use)), it displays a large 9x9 grid; see $(l:basics/tutorial_1)the tutorial entries$(/l) for more in-depth knowledge on using this grid.
@RECIPE (programmer): Hour Of Code

#vector_primer icon:textures/spell/operator_vector_construct.png A Primer On Vectors
@URL(https://www.youtube.com/watch?v=fNk_zzaMoSs) 3Blue1Brown: $(thing)Psi$(0) uses the concept of a Vector quite extensively. Therefore, if you haven't the foggiest idea what a vector is, I quite strongly recommend you watch the video below.$(p)The explanation in the next few pages is $(l)simplified$(), for beginners. Don't take it as definitive.
In the wonderful world of $(thing)Psi$(0) (and indeed in a $(thing)Minecraft$(0) world), all vectors are three-dimensional. In essence, they're just $(o)lists of three coordinates$(): $(o)x$(), $(o)y$(), $(o)z$().$(p)The $(o)x$()-coordinate represents east when positive and west when negative, the $(o)y$()-direction up and down, and the $(o)z$()-direction south and north.$(p)If this doesn't make sense yet, open the debug screen and run around, paying attention to the row labeled "XYZ:".
That list of three numbers, in fact, is the first type of vector you'll see: a $(l)position vector$().$(p)A position vector simply represents the location of a block, or an entity, or perhaps some empty space in the world. A single fixed location, represented by a list [$(o)x$(), $(o)y$(), $(o)z$()].$(p)However, not all vectors represent positions-- and it's important to note that $(l)any three numbers in a list make up a vector$().
The interesting thing about vectors is that they're extremely easy to add.$(p)For example, say we have a grass block at some location [$(o)x$(), $(o)y$(), $(o)z$()].$(p)If we wish to add another vector, say [0, 1, 0], to this one, all we would have to do is add corresponding numbers: our result would be [$(o)x$()+0, $(o)y$()+1, $(o)z$()+0], or just [$(o)x$(), $(o)y$()+1, $(o)z$()].
Since the $(o)y$()-component of our new vector has increased by one, and positive $(o)y$() means up, it simply represents the block above our grass block.$(p)The vector [0, 1, 0] represents the $(o)difference$() in position between our original and new vector, and it's our second type of vector: an $(l)offset vector$().
Offset vectors are what most spellslingers spend the majority of their time manipulating, so a mastery over them is key.$(p)Usually, a mage starts with a single position vector, then adds, subtracts, or otherwise combines offset vectors with this position vector in order to target their desired point in the world.
It's important to note that "offset" and "position" vectors are conceptual types, unique to the terminology of this tablet.$(p)Again: all $(thing)Psi$(0) vectors are just lists of three numbers, and there's nothing stopping you from using one type of vector as the other.$(p)In fact, in some contexts outside the scope of this book, the distinction doesn't even make $(o)sense$().
However, $(o)within$() the context of $(thing)Psi$(0), putting offset and position vectors where they don't belong can lead to quite unpredictable results indeed.$(p)Two rules of thumb:$(p)$(li)Most $(thing)Operators$(0) that accept vectors should take no more than one position vector;$(p)$(li)Most $(thing)Tricks$(0) that affect blocks should take $(o)only$() a position vector.$(p)These are general rules, though; some $(thing)Spell Pieces$(0) do act differently.
Offset vectors have $(l)magnitudes$().$(p)You can think of an offset vector's magnitude as its "length," or the distance between a position in the world, and that same position when the offset vector is added to it.$(p)For example, our earlier offset vector [0, 1, 0] simply moved the position one block-length up, so it had length (and therefore magnitude) 1.
Since a distance is always positive, so are vectors' magnitudes.$(p)Thus, consider the vector [0, -3, 0]: it represents down, three blocks-- yet the total distance moved is three blocks, and the "down" bit doesn't matter.$(p)Therefore, the magnitude of this vector is $(l)positive$() 3.
Magnitudes are a bit harder to calculate for vectors that $(o)aren't$() mostly zeroes.$(p)However, since the $(o)x$(), $(o)y$(), and $(o)z$() directions are all at right angles, we can use the Pythagorean Theorem to calculate any vector's magnitude.$(p)In particular, the magnitude for a vector [$(o)p$(), $(o)q$(), $(o)r$()] is the number √($(o)p$()²+$(o)q$()²+$(o)r$()²).
For example, the magnitude of the vector [3, -4, 0] is √(3²+(-4)²+0²), which comes out to exactly 5.$(p)(Most of the time, a vector magnitude doesn't come out to a whole number, though.)$(p)$(o)Sidenote: while you $()can$(o) find the magnitude of a position vector, the number you get is largely meaningless-- who $()cares$(o) about your distance from [0, 0, 0] (which is some arbitrary point near bedrock and world spawn)?$()
Almost all vectors also have $(l)directions$().$(p)An offset vector's direction is, well, the direction something would move if it followed the vector in a straight line.$(p)For example, the direction of [0, 1, 0] is simply straight up.$(p)The vector [1, 0, -1], on the other hand, represents one block east and one block north, so its direction is just straight ahead, due northeast.
(Most directions aren't so nice, usually looking like "36.86 degrees north of west, 22.62 degrees below the horizon.")$(p)Note that the only vector without a direction is [0, 0, 0] (the $(l)zero vector$()), since you have to be going somewhere $(o)else$() to have a direction.$(p)The direction of a position vector is almost as meaningless as its magnitude-- most $(thing)Spells$(0) don't need to know "where should I go to get away from bedrock at world spawn."
In fact, you can actually reconstruct a vector given only its magnitude and direction.$(p)This is not so surprising: if someone tells you which direction to go, and how far, you should know where to be.$(p)For example, the direction "up" and the magnitude 1 just correspond to the vector [0, 1, 0].
There are several simple ways to manipulate position and offset vectors.$(p)First, we can add a position and an offset vector to get another position vector (as we did earlier, with the grass block example).$(p)On the other hand, we can of course $(o)subtract$() two position vectors to get the offset vector representing the offset from one to the other:<br>[$(o)x$(), $(o)y$()+1, $(o)z$()] – [$(o)x$(), $(o)y$(), $(o)z$()] = [0, 1, 0].
Perhaps more interestingly, we can add two offset vectors, to get a single offset representing their combination.$(p)Adding this offset to a position vector would be equivalent to first adding one of its components to that position vector, then adding the other.
And last (but most certainly not least) of the simple operations: we can $(l)scale$() a vector, by multiplying it by a number.$(p)Note we're multiplying it by a number, and $(o)not$() another vector.$(p)If we wish to scale an vector [$(o)p$(), $(o)q$(), $(o)r$()] by a factor $(o)n$(), we simply multiply each of the vector's components by $(o)n$():<br>$(o)n$()·[$(o)p$(), $(o)q$(), $(o)r$()] = [$(o)n$()·$(o)p$(), $(o)n$()·$(o)q$(), $(o)n$()·$(o)r$()].
This final operation actually relates quite nicely indeed to the concepts of magnitude and direction.$(p)When you scale a vector by a number $(o)n$(), you:$(p)$(li)multiply its magnitude by the absolute value of $(o)n$(), and$(p)$(li)don't change its direction of $(o)n$() is positive, but reverse its direction if $(o)n$() is negative.$(p)If $(o)n$()=0, then of course the resulting vector is the zero vector.
If, on the other hand, we set $(o)n$()=-1, then we get a vector with the same magnitude (since the absolute value of -1 is 1), but that points in the opposite direction (since -1 is negative).$(p)This vector is known as the $(l)negative$() of the original, and when the two are added we get the zero vector.$(p)(This makes sense, since if we go somewhere, and then come back, our net movement is zero.)
If instead of multiplying, we $(o)divide$() a (nonzero) vector by its magnitude, we get a vector with magnitude 1 (since anything divided by itself is 1) but the same direction (since magnitudes are always positive).$(p)This is important; the operation is called $(l)normalizing$() a vector, and the vector that results (or, indeed, any vector with magnitude 1) is called a $(l)unit vector$().
Unit vectors have a fixed magnitude, so they only really represent direction.$(p)In fact, many $(thing)Spell Pieces$(0) related to direction return unit vectors, like $(piece)Operator: Vector Axis Raycast$(0) and $(piece)Operator: Entity Look$(0).$(p)In fact, there are $(thing)Operators$(0) to do most of what's been laid out in this article, usually with self-explanatory names.
$(li)Negating is $(piece)Operator: Vector Negate$(0);$(p)$(li)Normalizing is $(piece)Operator: Vector Normalize$(0);$(p)$(li)Scaling is $(piece)Operator: Vector Multiply$(0) and $(piece)Operator: Vector Divide$(0);Taking the magnitude is $(piece)Operator: Vector Magnitude$(0);$(p)$(li)Adding is $(piece)Operator: Vector Sum$(0);$(p)$(li)Subtracting is $(piece)Operator: Vector Subtract$(0).
Finally: vectors are still lists of three numbers. Don't lose sight of that.$(p)In a $(item)Spell Programmer$(0), they can be constructed from up to three numbers with $(piece)Operator: Vector Construct$(0).$(p)Conversely, a vector can also be broken back down into numbers with $(piece)Operator: Extract X$(0), $(piece)Operator: Extract Y$(0), and $(piece)Operator: Extract Z$(0).
Congratulations on making it this far through this tutorial!$(p)Again, this is just an introduction to vectors-- I've not said anything about dot or cross products, or vector projections, for example.$(p)But this should be more than enough to put together some quite interesting spells already.$(p)That's all-- now go forth and spellsling!

#tutorial_1+ Tutorial (1): Writing A Spell
Congratulations on getting acquainted with your brand-new $(thing)CAD$(0)! This tablet will serve as a reference manual for this mod, but certain entries (like this one) are tutorials, introducing you to the concepts and terms of a proper spellslinger. (Don't worry, this is the longest tutorial, as it covers all the basics.)
$(o)Note that many keywords in $(item)colored$(0) $(piece)text$(0) are links, and can be clicked on to learn more about their respective items, including their recipes.$()$(p)To get started with spell programming, you'll need (duh) a $(item)Spell Programmer$(0).$(p)Additionally, to actually execute your $(thing)Spells$(0), you'll need a better $(thing)CAD$(0) than the one you have right now-- you can construct one in your $(item)CAD Assembler$(0).
To that end, you probably want to make a $(item)Basic CAD Core$(0) and $(item)Basic CAD Socket$(0).$(p)You don't have to make another $(thing)Assembly$(0); you can put your current $(thing)CAD$(0) in a crafting grid to revert it back to one (since it's pretty much just an $(thing)Assembly$(0) anyway).$(p)Additionally, $(thing)Spells$(0) can't be cast directly out of a $(thing)CAD$(0); instead they're stored in $(item)Spell Bullets$(0), so to get rolling you'll need a small handful of those as well.
Once all your materials are gathered, the standard workflow for $(thing)Spell$(0) creation goes as follows:$(p)$(li)Construct a $(thing)Spell$(0) in the $(item)Programmer$(0);$(br)$(li)Copy the $(thing)Spell$(0) into a $(item)Spell Bullet$(0);$(br)$(li)Load the $(item)Spell Bullet$(0) into your $(thing)CAD$(0) using the $(item)CAD Assembler$(0);$(br)$(li)Hold your $(thing)CAD$(0), point, and cast.$(p)In this tutorial and the next, we'll walk you through this process.
When you open up your $(item)Spell Programmer$(0), you'll see a large grid-- this is where $(thing)Spells$(0) are made, and where the magic happens.$(p)$(thing)Psi$(0)'s programming system isn't $(o)quite$() a traditional, complex one; instead, $(thing)Spells$(0) are composed of simple actions, called $(thing)Tricks$(0), executed in order.$(p)The whole mod centers around simply getting $(thing)Tricks$(0) to do what you want them to.
$(thing)Psi$(0)'s $(thing)Spells$(0) are all created on the $(item)Programmer$(0)'s grid from $(thing)Spell Pieces$(0); you can add as many pieces of as many types to a grid as you want, though not all arrangements of $(thing)Spell Pieces$(0) will produce valid $(thing)Spells$(0).$(p)To add a piece to the grid, right-click where you want the piece to go, and select from the menu of pieces that pops up.
When selecting from the menu of $(thing)Spell Pieces$(0), you can hover over one to see its name, and click on it to place it in the grid.$(p)Don't worry about the myriad of pieces that appear for you; you can simply type to search for specific pieces, and press Enter to place the first search result.$(p)You can hold Shift and hover over the "?" button on the bottom-right to see the full list of shortcuts.
Start by placing the piece called $(piece)Trick: Debug$(0) anywhere on the grid.$(p)As mentioned before, $(thing)Tricks$(0) like this one are the $(thing)Spell Pieces$(0) responsible for interacting with the world.$(p)This is the simplest $(thing)Trick$(0); all it does is say something in your chat. Yet $(thing)Tricks$(0) can use your $(thing)Psi energy$(0) to do a huge variety of things.
Select a grid piece $(l)adjacent$() to your $(piece)Trick: Debug$(0), and place the piece called $(piece)Selector: Caster$(0) there.$(p)$(thing)Selectors$(0) are the $(thing)Spell Pieces$(0) that provide information about the surrounding world to $(thing)Spells$(0).$(p)This particular piece represents you, the eventual caster of this $(thing)Spell$(0). You'll probably use this one quite often, as it's a natural starting-point for your $(thing)Spells$(0).
Most non-$(thing)Selector$(0) $(thing)Spell Pieces$(0) (and, in fact, some $(thing)Selectors$(0) as well) need $(l)parameters$(), which tell the pieces what to perform their actions on.$(p)For example, we know that $(piece)Trick: Debug$(0) sends something to chat; its first parameter tells it $(o)what$() to say.$(p)$(o)Parameters also have $(l)data types$()$(o), or $(l)types$()$(o) for short, but we'll worry about those in a later tutorial.$()
Left-click your $(piece)Trick: Debug$(0) piece; you should see a panel appear on the left-hand side with two rows. Each row should have a label and several small arrows.$(p)These two rows represent the two parameters that $(piece)Trick: Debug$(0) takes.$(p)Ignore the row labeled "Number" for now; just know that the dot in the center means it's optional. For a $(thing)Spell$(0) to function, all $(o)non$()-optional parameters must be filled.
Look at the arrows labeled "Target," and select the one corresponding to where you placed $(piece)Selector: Caster$(0) (for example, if you placed it to the right of $(piece)Trick: Debug$(0), select the rightmost arrow that points left), so it appears that the $(thing)Selector$(0) piece is pointing towards the $(thing)Trick$(0) piece.
This will make the $(thing)Trick$(0) use the $(thing)Selector$(0) as its "Target" parameter.$(p)We say that $(piece)Trick: Debug$(0) $(l)accepts$() or $(l)takes$() $(piece)Selector: Caster$(0) as its "Target" parameter.$(p)Parameters are also known as $(l)arguments$(), or simply $(l)inputs$().$(p)$(o)(Technical note: In programming-vocabulary there's a subtle difference in the terms, but it's beyond the scope of this tablet.)$()
@IMAGE B(tutorial_1_spell): Your final $(thing)Spell$(0) should look something like this
At this point, the X in the upper-left hand corner of the $(item)Programmer$(0) should have turned into a check-mark.$(p)A check-mark means that the $(thing)Spell$(0) $(l)compiled successfully$() (which is a compact way of saying "the $(item)Programmer$(0) made sure that all the $(thing)Spell Pieces$(0) you've placed fit together correctly"). 
If at any time the X is present (which means that the compilation $(l)failed$() or $(l)errored$()), you can hover over it to see the problem with your $(thing)Spell$(0) and correct that problem.$(p)Once your $(thing)Spell$(0) compiles successfully, it can be copied into a $(item)Spell Bullet$(0) and cast. And that's exactly what we'll do in $(l:basics/tutorial_2)the next tutorial$(/l)!

#tutorial_2+ Tutorial (2): Casting A Spell
So, you've written your first $(thing)Spell$(0)! Actually casting it, though, will take a few extra steps.$(p)First, close out your $(item)Spell Programmer$(0), hold a $(item)Spell Bullet$(0) (which you should have prepared in the last tutorial), and use ($(k:use)) the bullet on the Programmer. You should hear a chime, and the bullet should rename itself to "Debug."
The bullet now contains a copy of the $(thing)Spell$(0) you've written, and is ready to be loaded into your $(thing)CAD$(0).$(p)To load a $(item)Spell Bullet$(0) into your $(thing)CAD$(0), open your $(item)CAD Assembler$(0) and insert your $(thing)CAD$(0) into the leftmost slot. Some of the slots below it should open; place the bullet with the $(thing)Spell$(0) you've written in one of these slots. Take your $(thing)CAD$(0) back out.
$(thing)CADs$(0) can hold multiple $(item)Spell Bullets$(0), and therefore multiple $(thing)Spells$(0); the active $(thing)Spell$(0) to be cast can be switched on-the-fly.$(p)To select a $(thing)Spell$(0) to cast, hold your $(thing)CAD$(0) in either hand and hold down the $(thing)Psi master keybind$(0) ($(k:psimisc.keybind)).$(p)A HUD should appear; hover over the $(thing)Spell$(0) labeled "Debug" (the one you just wrote) and release the key to select it.
When you cast the $(thing)Spell$(0) ($(k:use)), you should see displayed in chat a long block of text that includes your username and coordinates. If so: congratulations! You've managed to write and cast your first $(thing)Spell$(0)!$(p)If you need to craft more $(item)Psidust$(0), re-open the HUD and select a slot without a $(thing)Spell$(0) stored, then cast at $(item)Redstone Dust$(0) as you normally would.
$(l)A sidenote: you should carry only one $(thing)CAD$(0) at a time.$()$(p)If more than one is carried, their channeled $(thing)Psi$(0) energies interfere, shorting out any $(thing)Spells$(0) cast. This phenomenon, known as "cast jamming," is best avoided by simply keeping to one-$(thing)CAD$(0)-per-mage.$(p)Once you've successfully cast your Debug $(thing)Spell$(0), you can move on to $(l:basics/tutorial_3)the next tutorial$(/l).

#tutorial_3+ Tutorial (3): Types & Numbers
Open up your $(item)Spell Programmer$(0) and take a look at your "Debug" $(thing)Spell$(0) again.$(p)Remember the "Number" parameter on $(piece)Trick: Debug$(0) that we saw in $(l:basics/tutorial_1)the first tutorial$(/l)? We mentioned previously that that parameter has an extra dot in the center, meaning it can be disabled. But this time, we $(o)won't$() disable it.
$(piece)Trick: Debug$(0)'s "Number" parameter, when used, is printed as a label of sorts, so that multiple $(piece)Trick: Debug$(0)s in a complex $(thing)Spell$(0) can be differentiated.$(p)The $(l)type$() of this parameter is "Number," which means that the parameter will only accept arguments that output (or $(l)return$()) Numbers.$(p)(The first parameter, "Target," accepts the special type "Any," which means it can accept anything.)
If you hold Shift and hover over a Spell Piece, it'll tell you the types of all its parameters, as well as its output's type. For example, we can see that the $(piece)Selector: Caster$(0) piece returns an Entity, which isn't a Number. So we'll need some other piece to represent one.
@IMAGE (tutorial_3_tooltip): Tooltip for $(piece)Selector: Caster$(0); it returns an Entity
Choose an empty grid piece adjacent to $(piece)Trick: Debug$(0), and place the piece called $(piece)Constant: Number$(0).$(p)If you Shift-hover over this piece, you'll see that it $(o)does$() return a Number (in fact, it returns a Number Constant, which is a Number but more specific).$(p)Therefore, if you left-click your $(piece)Trick: Debug$(0) again and point its Number parameter at the $(piece)Constant: Number$(0), your $(thing)Spell$(0) should compile.
To run your new-and-improved Debug $(thing)Spell$(0), you might believe that you need to unload the bullet, re-copy the $(thing)Spell$(0), reload the bullet, and re-select the $(thing)Spell$(0).$(p)Luckily, your $(thing)CAD$(0) comes with a shortcut: simply select your Debug $(thing)Spell$(0) on your $(thing)CAD$(0) and use ($(k:use)) it on your $(item)Programmer$(0), and the $(thing)Spell$(0) stored in the corresponding bullet will update itself to the $(item)Programmer$(0)'s version.
If you cast your Debug $(thing)Spell$(0) now, you'll notice that you get the same long block of text as before, but with a bracketed zero in front: in fact, the same zero that was displayed in the $(piece)Constant: Number$(0) piece when you placed it.$(p)So the logical next question is: How do we display a number $(o)other$() than zero?
Well, the $(piece)Constant: Number$(0) piece is special: to set its stored constant, all you have to do is select the piece and simply type a new number.$(p)All other $(thing)Spell Pieces$(0) are configured only from the left-hand parameter panel.$(p)$(o)Technical wayside: all Number Constants count as Numbers, but plain Numbers don't count as Number Constants. Only $(thing)Constant$(0) $(thing)Spell Pieces$(0) return Number Constants.$()
Try editing the number stored in the $(piece)Constant: Number$(0), updating the $(thing)Spell$(0) stored in your $(thing)CAD$(0), and re-casting. You should see that the prefixed number has, in fact, changed! Neat!
Now, here's the thing: we've hooked $(piece)Trick: Debug$(0) up to two different inputs at once.$(p)And truth be told, $(o)most$() $(thing)Spell Pieces$(0) take two (or even three) inputs. And when it comes right down to it, your $(thing)Spell$(0)'s inputs might end up adjacent to one another.$(p)That's where $(piece)Connectors$(0) come in.
Connectors are simple pieces, yet powerful: They take one input, of any type, and return that same input. Thus, if a certain $(thing)Spell Piece$(0) requires as input another piece that's two grid-spaces away, you can connect them with a $(piece)Connector$(0).
@IMAGE (tutorial_3_connector): Bridge to Terabithia
Of course, the true power of a $(piece)Connector$(0) is that they can connect to each $(o)other$(): so you can of course daisy-chain them together to connect $(thing)Spell Pieces$(0) from as far-away as you please.$(p)Play around with some $(piece)Connectors$(0), and as soon as you feel comfortable with them you can move on to $(l:basics/tutorial_5)the next tutorial$(/l)!
@IMAGE (tutorial_3_chain): The long way around

#tutorial_4+ Tutorial (4): Move It
Okay, okay. I know what you're thinking: "This is boring. When do we start doing cool stuff?" Well... now!$(p)Let's introduce a $(thing)Trick$(0) that actually interacts with the world-- introducing: $(piece)Trick: Add Motion$(0).$(p)This trick (as you'd expect) takes an entity, and adds motion to it (i.e. gives it a push) in a certain direction.
Examples of entities include: you, the caster; a chicken; a zombie; a minecart; a falling sand block; an arrow; the Wither.$(p)This $(thing)Trick$(0) takes as parameters an Entity (which represents the entity to move), a Vector (the direction to push it in), and a Number Constant (how hard the $(thing)Trick$(0) should push the entity).$(p)$(o)Note: If you don't understand what the word "vector" means, $(l:basics/vector_primer)this entry$(/l) should serve as a good introduction.$()
Let's write a $(thing)Spell$(0) that, when cast, simply boosts its caster forwards, using $(piece)Trick: Add Motion$(0).$(p)As mentioned before, $(piece)Selector: Caster$(0) returns an Entity (namely: you, the caster), so we can use that as the first parameter to $(piece)Trick: Add Motion$(0).$(p)We'd like the trick to boost you $(o)forward$()-- that is, $(o)in the direction you're looking$(). To do that, let's introduce our next piece: $(piece)Operator: Entity Look$(0).
No $(thing)Operator$(0) pieces change the world around them in any way, nor do they pull information from it (with a few exceptions). Instead, they merely $(o)transform$() information into more useful forms.$(p)In particular, $(piece)Operator: Entity Look$(0) accepts an Entity, and returns a unit Vector: the direction the Entity is looking.$(p)Thus, one of these, hooked up to a $(piece)Selector: Caster$(0), will return a Vector that points wherever you're looking at.
Finally, for the last parameter of $(piece)Trick: Add Motion$(0), a simple $(piece)Constant: Number$(0) will do.$(p)Let's put this $(thing)Spell$(0) all together: first, open up your $(item)Spell Programmer$(0) and clear any $(thing)Spell$(0) currently on it. Then, place a $(piece)Trick: Add Motion$(0) near the middle of the grid.
Place a $(piece)Selector: Caster$(0) directly above the $(thing)Trick$(0), an $(piece)Operator: Entity Look$(0) to its right, and a $(piece)Constant: Number$(0) to its left.$(p)Fill in a value for the $(thing)Constant$(0) (I recommend the number 3).$(p)Place a $(piece)Connector$(0) between the $(thing)Operator$(0) and the $(thing)Selector$(0), and then set up all the parameters for the $(thing)Operator$(0) and $(thing)Trick$(0) so the $(thing)Spell$(0) compiles-- it should look something like the image on the next page.
@IMAGE (tutorial_4_spell): When push comes to shove
Copy the $(thing)Spell$(0) into your $(thing)CAD$(0), look straight ahead, and cast. If you get thrown forward, then congratulations! You've just finished writing your first real $(thing)Spell$(0)!$(p)$(o)Note: Casting your new $(thing)Spell$(0) too many times in a row might be bad for your health. More on this in $(l:basics/tutorial_5)the next tutorial$(/l).$()

#tutorial_5+ Tutorial (5): Limits
Open your $(item)Spell Programmer$(0) again, and review the $(thing)Spell$(0) you wrote in $(l:basics/tutorial_4)the last tutorial$(/l).$(p)When it compiled correctly, you should have seen five icons appear to the right of the grid, each with two numbers. These numerical stats define the practical limits on exactly what $(thing)Spells$(0) you're able to cast.
@IMAGE B(tutorial_5_stats): The stats for your Add Motion $(thing)Spell$(0) (assuming your constant was 3)
#!complexity The first stat is $(thing)Complexity$(0); the total number of $(thing)Operators$(0), $(thing)Selectors$(0), and non-debug $(thing)Tricks$(0) in the $(thing)Spell$(0).$(p)Its maximum value is determined by the $(thing)CAD Core$(0) you have installed; if a $(thing)Spell$(0)'s $(thing)Complexity$(0) exceeds your $(thing)CAD$(0)'s capacity, it won't be castable.
#!potency The second is $(thing)Potency$(0); the approximate total power draw of all $(thing)Tricks$(0) used in the $(thing)Spell$(0).$(p)Some $(thing)Tricks$(0) have a fixed $(thing)Potency$(0) cost per-use. However, most $(thing)Tricks$(0) that have a Number Constant-type parameter use it to determine their $(thing)Potency$(0); the higher the constant, the greater the $(thing)Potency$(0).$(p)Your $(thing)CAD$(0)'s maximum $(thing)Potency$(0) depends on its $(thing)Assembly$(0) component.
#!cost The third stat is special-- it's called $(thing)Cost$(0), and it's unique in that your $(thing)CAD$(0) sets no limits on it.$(p)Instead, each time a $(thing)Spell$(0) is cast, it consumes its $(thing)Cost$(0) from your own body's $(thing)Psi energy$(0).$(p)The first number shown is the $(o)ideal$() $(thing)Cost$(0) of the $(thing)Spell$(0)-- nearly all $(thing)CAD Assemblies$(0) have inefficiencies that increase the $(thing)Cost$(0). The higher the $(thing)Assembly$(0)'s $(thing)Efficiency$(0), the closer to ideal the actual $(thing)Cost$(0) (the second number) becomes.
Your $(thing)Psi energy$(0) regenerates at around 500 units per second, limiting the speed at which you can cast $(thing)Spells$(0).$(p)Note that if you cast a $(thing)Spell$(0) without enough $(thing)Psi energy$(0) available (known as $(l)overdrawing$()), your $(thing)CAD$(0) will draw the excess cost from your own health, and promptly disable itself until your $(thing)Psi energy$(0) fully regenerates, for your own protection.$(p)Be careful: overdrawing can have lethal consequences!
#!projection The fourth stat displayed on the $(item)Programmer$(0) is $(thing)Projection$(0): the total number of non-debug $(thing)Tricks$(0) in the $(thing)Spell$(0).$(p)Your $(thing)CAD$(0)'s $(thing)Core$(0) determines your maximum $(thing)Projection$(0) per-$(thing)Spell$(0); too many tricks and the $(thing)Spell$(0) is uncastable.
#!bandwidth And the fifth and final stat is $(thing)Bandwidth$(0): the width or height of the $(thing)Spell$(0), measured in grid spaces-- whichever is larger.$(p)Its maximum is determined by your $(thing)CAD Socket$(0).$(p)This is, with a bit of ingenuity, one of the more interesting stats to work with; if your $(thing)Spell$(0) is too big, the technique of moving some pieces around and eliminating others to pack it into a smaller space is known as $(l)compression$().
There's one final limitation on $(thing)Spells$(0): no $(thing)Trick$(0) can affect any blocks or entities further than 32 blocks away from its $(thing)Focal Point$(0)-- keep that in mind.$(p)For the normal $(item)Spell Bullets$(0) you've been using, their $(thing)Focal Point$(0) is just you, the caster.$(p)There's $(l:basics/tutorial_6)one final tutorial$(/l) lined up, putting most of what we've learned together, and then we'll cut you loose into the wider world of $(thing)Psi$(0). Good luck!

#tutorial_6+ Tutorial (6): EXPLOSION
Do you like explosions?$(p)Of course you do. Everyone loves explosions!$(p)So let's make a $(thing)Spell$(0) that blows up whatever you're looking at when you cast it.$(p)What could possibly go wrong?
To write this $(thing)Spell$(0), let's start with the $(thing)Trick$(0) we'll use to cause an explosion, and work backwards.$(p)Conveniently, it's named $(piece)Trick: Explode$(0)-- so open up your $(item)Spell Programmer$(0), clear out the grid, and place a $(piece)Trick: Explode$(0) near the middle.$(p)Shift-hovering over it reveals that it accepts a Vector and a Number Constant as parameters.
The Number Constant parameter represents the explosion's power-- easy enough to fill with a $(piece)Constant: Number$(0) piece.$(p)The Vector, on the other hand, accepts the position vector of the location you want the explosion to go off at. This is what'll take a bit more effort to calculate.
$(l:basics/tutorial_5)Last tutorial$(/l), we used $(piece)Operator: Entity Look$(0).$(p)However, that $(thing)Operator$(0) returns a unit vector, and $(piece)Trick: Explode$(0) needs a position, so feeding that piece directly into the $(thing)Trick$(0) would probably not produce the results we want.$(p)So let's introduce another $(thing)Operator$(0): namely, $(piece)Operator: Entity Position$(0).
$(piece)Operator: Entity Position$(0) accepts an Entity (like the caster of the $(thing)Spell$(0)), and returns that entity's position (to be more precise: for a player like you, it returns your position at eye-level).$(p)However, we don't want to pass this directly into $(piece)Trick: Explode$(0), either-- because it would quite literally explode in your face when cast.
What we $(o)could$() do here is simply scale up the vector we got from $(piece)Operator: Entity Look$(0) by a factor of, say, 10, and then add this to $(piece)Operator: Entity Position$(0)'s output.$(p)When fed into $(piece)Trick: Explode$(0), this would create a $(thing)Spell$(0) that, when cast, would create an explosion $(o)exactly ten blocks away from you, in the direction you're looking$().
But the limitations of this $(thing)Spell$(0) seem obvious: if you want to blow something up that's closer or further than ten blocks away, you'll have to do some awkward moving-around and guesstimating of distances.$(p)Not very practical, all things considered.$(p)Instead, let's use a smarter operator: $(piece)Operator: Vector Raycast$(0).
This $(thing)Operator$(0)'s function is quite simple, intuitively; it accepts a position vector and a "ray" vector (which is just a vector to represent direction).$(p)Its return value pretty much represents "if I stood there and looked in that direction, what position would I be looking at?", which makes it perfect for our purposes.$(p)(For more details, including what the "Max" argument does, read the page about $(piece)Operator: Vector Raycast$(0).)
So! To build this $(thing)Spell$(0), let's work backwards.$(p)If you haven't done so already, place a $(piece)Constant: Number$(0) near the $(piece)Trick: Explode$(0) (if you're still using the $(thing)CAD$(0) you built in $(l:basics/tutorial_1)the first tutorial$(/l), 1.4 would be a good number to set it to).$(p)Then, place a $(piece)Operator: Vector Raycast$(0) next to the $(thing)Trick$(0) as well, and hook the $(thing)Trick$(0) up to the other two $(thing)Spell Pieces$(0).
Next, place an $(piece)Operator: Entity Position$(0) and an $(piece)Operator: Entity Look$(0), then connect your $(piece)Operator: Vector Raycast$(0) to the two.$(p)Make sure to hook "Position" up to Entity Position and "Ray" up to Entity Look, and not the other way around, or else you'll get some odd results/errors when you cast the $(thing)Spell$(0).$(p)Finally, place a $(piece)Selector: Caster$(0), and hook this up to the two Entity operators.
@IMAGE (tutorial_6_spell): Something along these lines
Once your $(thing)Spell$(0) compiles successfully, load it into your $(thing)CAD$(0), take careful aim at something (preferably something you don't care much about), and cast.$(p)If that thing you're looking at explodes, take a moment to savor your newfound power.$(p)Just, er, try not to cast it at your own two feet.
One final note: Try casting your new "Explode" $(thing)Spell$(0) at something that's more than 32 blocks away (or at nothing, like the sky).$(p)You should see no explosion, and an error should pop up in chat, telling you "$(c)Spell Target is outside maximum 32 block radius.$(0)"$(p)This 32-block limit was discussed last tutorial, but these sorts of errors popping up in chat can get rather annoying.
To fix this, simply place an $(piece)Error Suppressor$(0) piece anywhere on the grid, and the resulting $(thing)Spell$(0) will instead fail silently, when cast.$(p)(You might want to remove the piece when debugging, though. Errors $(o)can$() be useful sometimes.)
This concludes this set of tutorials!$(p)Have a read through the rest of this book for an idea of exactly what you can do with this mod. Experienced mages can do quite terrifying things, after all.$(p)It's up to you to experiment with your $(thing)CAD$(0) and $(item)Spell Programmer$(0), and to create your own unique $(thing)Spells$(0).$(p)Good luck, and welcome to the wide world of $(thing)Psi$(0)!

##components icon:cad_assembly_psimetal Materials & Components

#psidust+ icon:psidust Psidust
$(item)Psidust$(0) is a material transmuted from $(item)Redstone Dust$(0) by an unfocused burst of $(thing)Psi energy$(0), and is in fact a good conductor of said energies.$(p)Therefore, it's a critical component in low-tier $(thing)CADs$(0), since it's used in simple $(l:components/core#basic)$(thing)CAD Cores$(0)$(/l), $(l:components/socket#basic)$(thing)Sockets$(0)$(/l), and $(l:components/battery#basic)$(thing)Batteries$(0)$(/l), as well as all $(thing)CAD Colorizers$(0).$(p)It's also used in $(item)Spell Bullets$(0).
@ITEM (psidust+): To create $(item)Psidust$(0), first throw some $(item)Redstone Dust$(0) on the ground.$(p)Then, stand nearby and cast ($(k:use)) with a $(thing)CAD$(0) $(l)that has no $(thing)Spell$(0) selected$() to convert the redstone into $(item)Psidust$(0).$(p)$(item)Psidust$(0) can also be created with any of the $(piece)infusion tricks$(0).

#psimetal+ icon:psimetal Psimetal
$(item)Psimetal$(0) is a material transmuted from $(item)Gold Ingots$(0) that conducts, stores, and transfers $(thing)Psi energy$(0) $(o)much$() better than $(item)Psidust$(0) does.$(p)In addition to being a component in more powerful $(thing)CAD Cores$(0), $(thing)Sockets$(0), and $(l:components/battery#extended)$(thing)Batteries$(0)$(/l), it can be fashioned into a superior $(l:components/assembly#psimetal)$(thing)CAD Assembly$(0)$(/l). It's also used to craft $(item)Psimetal Tools$(0) and $(item)Armor$(0), as well as $(item)Ebony & Ivory Ingots$(0).
@ITEM (psimetal+): To create $(item)Psimetal$(0), first drop $(item)Gold Ingots$(0) on the ground.$(p)Then, stand nearby, and cast a $(thing)Spell$(0) with $(piece)Trick: Infusion$(0) (or any other $(piece)infusion trick$(0)) as one of its $(thing)Tricks$(0) to convert the gold into $(item)Psimetal$(0).

#psigem+ icon:psigem Psigems
$(item)Psigems$(0) are crystals transmuted from $(item)Diamonds$(0) whose refractive properties make them extraordinarily good at conducting, transferring, and storing $(thing)Psi energy$(0).$(p)These are used to fashion top-of-the-line $(thing)CAD Cores$(0), $(thing)Sockets$(0), and $(l:components/battery#ultradense)$(thing)Batteries$(0)$(/l), and as essential components in $(item)Psimetal Tools$(0) and $(item)Armor$(0).
@ITEM (psigem+): To create a $(item)Psigem$(0), first throw a $(item)Diamond$(0) on the ground.$(p)Then, stand nearby, and cast a $(thing)Spell$(0) with $(piece)Trick: Greater Infusion$(0) (or $(piece)Trick: Ebony & Ivory$(0)) as one of its tricks to convert the $(item)Diamond$(0) into a $(item)Psigem$(0).

#ebony_ivory icon:ivory_substance Ebony & Ivory
The $(thing)End$(0) is much closer to a dimension of the mind than the $(thing)Overworld$(0). Therefore, its essences are much more conductive to $(thing)Psi energy$(0), which derives from the mind as well.$(p)$(piece)Trick: Ebony & Ivory$(0) can be used to capture these essences in $(item)Coal$(0) and $(item)Nether Quartz$(0), transmuting them into $(item)Ebony Substance$(0) and $(item)Ivory Substance$(0), respectively.
Unfortunately, as it turns out, neither $(item)Ebony$(0) nor $(item)Ivory Substance$(0) plays nicely with $(thing)Overworld$(0)-y materials.$(p)This means that fashioning them into $(thing)CAD Cores$(0), $(thing)Sockets$(0), and $(thing)Batteries$(0) proves rather difficult.$(p)We $(o)can$(), however, coat $(item)Psimetal Ingots$(0) with the stuff, yielding $(item)Ebony$(0) and $(item)Ivory Psimetal Ingots$(0), respectively, which are just about stable enough to be shaped into $(thing)CAD Assemblies$(0).
@ITEM (ebony_substance+): To create $(item)Ebony Substance$(0), first travel to the $(thing)End$(0), and drop $(item)Coal$(0) on the ground there.$(p)Then, stand nearby, and cast a $(thing)Spell$(0) with $(piece)Trick: Ebony & Ivory$(0) as one of its $(thing)Tricks$(0) to convert the $(item)Coal$(0) into $(item)Ebony Substance$(0).
@ITEM (ivory_substance+): To create $(item)Ivory Substance$(0), first travel to the $(thing)End$(0), and drop $(item)Nether Quartz$(0) on the ground there.$(p)Then, stand nearby, and cast a $(thing)Spell$(0) with $(piece)Trick: Ebony & Ivory$(0) as one of its $(thing)Tricks$(0) to convert the $(item)Nether Quartz$(0) into $(item)Ivory Substance$(0).
@RECIPE (ebony_psimetal): Dark'ness Dementia Raven Way
@RECIPE (ivory_psimetal): No elephants were harmed in its creation

#assembly icon:cad_assembly_iron Assemblies
The $(thing)CAD Assembly$(0) is simple in structure, yet the single most important component of a $(thing)CAD$(0).$(p)An $(thing)Assembly$(0) is responsible for channeling its user's $(thing)Psi energy$(0)-- it's simply a conveniently-shaped conduit for the task.$(p)All $(thing)Psi$(0) $(thing)CADs$(0) are crafted from four ingots of their component material in a crafting grid, shaped in a sideways L.$(p)
The $(thing)Assembly$(0) is the only $(thing)CAD$(0) component that's strictly necessary in an $(item)CAD Assembler$(0)-- indeed, any $(thing)CAD$(0) consisting of just an $(thing)Assembly$(0) can be reverted to one in a crafting grid.$(p)Every $(thing)Assembly$(0) has a $(thing)Potency$(0): roughly, the maximum rate it can channel $(thing)Psi energy$(0) at.$(p)It also has an $(thing)Efficiency$(0), which is the percent of its user's $(thing)Psi energy$(0) that it can actually $(o)use$() in a $(thing)Spell$(0)-- a higher $(thing)Efficiency$(0) is better.
#!iron @ITEM (cad_assembly_iron): The humble $(item)Iron CAD Assembly$(0) has the lowest $(thing)Potency$(0) of any $(thing)Assembly$(0) in this book.$(p)But it's relatively cheap, and crafts $(item)Psidust$(0) as well any other $(thing)CAD$(0), so it's the go-to $(thing)Assembly$(0) for beginners.
@RECIPE (cad_assembly_iron): Sleek and simple
#!gold @ITEM (cad_assembly_gold): The $(item)Gold CAD Assembly$(0) has a slightly lower $(thing)Efficiency$(0) than its $(l:components/assembly#iron)$(item)Iron$(0)$(/l) counterpart (in fact, the lowest of any in this book).$(p)However, it also boasts a fifty-percent higher $(thing)Potency$(0) than the iron version.
@RECIPE (cad_assembly_gold): A bit heavy to carry around, though
#!psimetal @ITEM (cad_assembly_psimetal): The $(item)Psimetal CAD Assembly$(0) has a higher $(thing)Efficiency$(0) than an $(l:components/assembly#iron)$(item)Iron Assembly$(0)$(/l) as well as a higher $(thing)Potency$(0) than a $(l:components/assembly#gold)$(item)Gold Assembly$(0)$(/l), making it quite versatile indeed.$(p)In fact, both $(piece)Trick: Greater Infusion$(0) and $(piece)Trick: Ebony & Ivory$(0) require a $(thing)CAD$(0) with an $(thing)Assembly$(0) of this caliber or higher to cast.
@RECIPE (cad_assembly_psimetal): Best of both worlds
#!ebony @ITEM (cad_assembly_ebony_psimetal): The $(item)Ebony Psimetal CAD Assembly$(0) is a top-tier type of $(item)Assembly.$(0)$(p)It's slightly less efficient, but can handle more $(thing)Potency$(0), than its $(l:components/assembly#ivory)$(item)Ivory$(0)$(/l) counterpart.
@RECIPE (cad_assembly_ebony): The big guns (so to speak)
#!ivory @ITEM (cad_assembly_ivory_psimetal): The $(item)Ivory Psimetal CAD Assembly$(0) is a top-tier type of $(item)Assembly.$(0)$(p)It's slightly less potent, but has a greater $(thing)Efficiency$(0), than its $(l:components/assembly#ebony)$(item)Ebony$(0)$(/l) counterpart.
@RECIPE (cad_assembly_ivory): Go with the flow
#core icon:cad_core_basic Cores
A $(thing)CAD$(0)'s $(thing)Core$(0) is essentially its CPU-- it's responsible for reading a $(thing)Spell$(0) from the $(thing)Socket$(0), running calculations, and using $(thing)Psi energy$(0) to cast the effects of $(thing)Tricks$(0) in the world.$(p)$(thing)CAD Cores$(0) are crafted with four of a $(thing)Psi$(0)-conductive material placed around a central piece of dust (as a processor).
Every $(thing)CAD Core$(0) has a $(thing)Complexity$(0), which is the maximum number of computations ($(thing)Selectors$(0), $(thing)Operators$(0), non-debug $(thing)Tricks$(0)) the $(thing)Core$(0) can perform per-$(thing)Spell$(0).$(p)A $(thing)Core$(0) also has a $(thing)Projection$(0), which is simply the total number of non-debug $(thing)Tricks$(0) it can perform at once.
#!basic @ITEM (cad_core_basic): Crafted from an $(item)Iron$(0) shell around a piece of $(item)Psidust$(0), the $(item)Basic CAD Core$(0) is often the first $(thing)CAD Core$(0) a mage crafts.$(p)It's not fantastic (in particular, it can only cast one $(thing)Trick$(0) at a time), but it's quite sufficient for a beginner's needs.
@RECIPE (cad_core_basic): Spell it out
#!overclocked @ITEM (cad_core_overclocked): Substituting $(item)Psimetal$(0) for $(item)Iron$(0) around a $(thing)CAD Core$(0) allows us to use a different dust component in the $(thing)Core$(0)'s center.$(p)If $(item)Redstone Dust$(0) is used for the dust, we get a $(item)Overclocked CAD Core$(0), which boasts twice the $(thing)Complexity$(0) of its $(l:components/core#basic)$(item)Basic$(0)$(/l) predecessor, and thrice the $(thing)Projection$(0).
@RECIPE (cad_core_overclocked): A hat trick
#!conductive @ITEM (cad_core_conductive): If, instead, we place a piece of $(item)Glowstone Dust$(0) within a $(item)Psimetal$(0) shell, we create a $(item)Conductive CAD Core$(0).$(p)This $(thing)Core$(0) handles less $(thing)Complexity$(0) than its $(item)Redstone Dust$(0)-based counterpart, but can handle four $(thing)Tricks$(0) at once, over the $(l:components/core#overclocked)$(item)Overclocked$(0)$(/l)'s three.
@RECIPE (cad_core_conductive): Some real tricky business
#!hyperclocked @ITEM (cad_core_hyperclocked): Embedding two $(item)Psigems$(0) into the recipe for a $(thing)CAD Core$(0) creates $(o)serious$() performance benefits.$(p)The $(item)Hyperclocked CAD Core$(0), with $(item)Redstone Dust$(0) at its center, has double the $(thing)Complexity$(0) of a $(l:components/core#conductive)$(item)Conductive$(0)$(/l) core $(o)and$() double the $(thing)Projection$(0) of an $(l:components/core#overclocked)$(item)Overclocked$(0)$(/l) one.
@RECIPE (cad_core_hyperclocked): Won't tell the time, though
#!radiative @ITEM (cad_core_radiative): If we use $(item)Psigems$(0) in a $(thing)CAD Core$(0) with $(item)Glowstone Dust$(0) at its center, we get a $(item)Radiative CAD Core$(0).$(p)This $(thing)Core$(0) has a lesser $(thing)Projection$(0) than the $(l:components/core#hyperclocked)$(item)Hyperclocked$(0)$(/l) one, but has the capability to execute a staggering $(o)seven$() $(thing)Tricks$(0) per-cast.
@RECIPE (cad_core_radiative): No technetium involved

#socket icon:cad_socket_basic Sockets
A $(thing)CAD$(0)'s $(thing)Socket$(0) is basically its bullet clip.$(p)It's what $(item)Spell Bullets$(0) are loaded into, and it's responsible for transferring the compiled $(thing)Spells$(0) contained within the $(item)Bullets$(0) to the $(thing)Core$(0) for processing.$(p)$(thing)Sockets$(0) are crafted with a piece of dust, which interfaces with the $(item)Bullets$(0), placed on a metallic substrate.
A $(thing)Socket$(0) has a $(thing)Bandwidth$(0), which is the maximum size (in grid spaces) of a $(thing)Spell$(0) that it can transfer to a $(thing)Core$(0), all at once-- for example, a $(thing)Socket$(0) with bandwidth 5 could transfer a spell up to 5x5 in dimension.$(p)It also has, well, a number of $(thing)Sockets$(0), which are compartments that can hold one $(item)Spell Bullet$(0) each.
#!basic @ITEM (cad_socket_basic): The $(item)Basic CAD Socket$(0) is the simplest of $(thing)Sockets$(0), crafted from $(item)Psidust$(0) on a substrate of $(item)Iron$(0).$(p)It holds up to four $(item)Spell Bullets$(0) at a time, and can transfer spells up to 5x5 in size.
@RECIPE (cad_socket_basic): Plug & chug
#!signaling @ITEM (cad_socket_signaling): Replacing the $(item)Iron$(0) substrate in a $(thing)Socket$(0) with a metal that's more conductive to $(thing)Psi energy$(0) (i.e. $(item)Psimetal$(0)) allows us to choose a different dust to interface with the $(item)Spell Bullets$(0).$(p)Using $(item)Redstone Dust$(0) gets us a $(item)Signaling CAD Socket$(0), which holds up to six $(item)Bullets$(0), each with a $(thing)Spell$(0) up to 7x7 in size.
@RECIPE (cad_socket_signaling): Perfect for Russian Roulette
#!large @ITEM (cad_socket_large): Using $(item)Glowstone Dust$(0) on a $(item)Psimetal$(0) substrate yields a $(item)Large CAD Socket$(0).$(p)This $(thing)Socket$(0) can't handle $(thing)Spells$(0) as large as its $(l:components/socket#signaling)$(item)Signaling$(0)$(/l) counterpart can, only managing those up to 6x6 in size, but holds up to eight $(item)Bullets$(0) at a time.
@RECIPE (cad_socket_large): Practically endless
#!transmissive @ITEM (cad_socket_transmissive): Augmenting a $(thing)Socket$(0) in its recipe with a $(item)Psigem$(0) makes it transfer more data, faster.$(p)A $(l:components/socket#signaling)$(item)Signaling CAD Socket$(0)$(/l) with such an augmentation becomes a $(item)Transmissive CAD Socket$(0), which can hold up to ten $(item)Bullets$(0), and can in fact handle $(o)any$() $(thing)Spell$(0)that fits in a $(item)Spell Programmer$(0).
@RECIPE (cad_socket_transmissive): Avaritia's Bane
#!huge @ITEM (cad_socket_huge): On the other hand, a $(l:components/socket#large)$(item)Large CAD Socket$(0)$(/l), augmented with a $(item)Psigem$(0), becomes the imaginatively-named $(item)Huge CAD Socket$(0).$(p)One of these doesn't have the $(thing)Bandwidth$(0) of its $(l:components/socket#transmissive)$(item)Transmissive$(0)$(/l) counterpart (only spells that are 8x8 or smaller), but can store up to a full dozen $(item)Spell Bullets$(0).
@RECIPE (cad_socket_huge): Hope Ophiuchus doesn't mind

#battery icon:cad_battery_basic Batteries
A $(thing)CAD Battery$(0) is an optional attachment to a $(thing)CAD$(0), allowing it to indefinitely store a small amount of its user's $(thing)Psi energy$(0)-- its $(thing)Overflow$(0) represents how much.$(p)A $(thing)Battery$(0) discharges after its user's main supply of $(thing)Psi energy$(0) runs out, but before the $(thing)CAD$(0) taps into its user's health.
In effect, a $(thing)Battery$(0) is meant to be a small safety net of stored $(thing)Psi energy$(0).$(p)It's there so that you can overdraw a $(o)bit$(), without taking damage or having to wait for your $(thing)Psi energy$(0) to refill.$(p)All $(thing)Batteries$(0) are crafted with a $(thing)Psi energy$(0)-conductive material enclosed between an $(item)Iron$(0) and a $(item)Gold Ingot$(0).
#!basic @RECIPE (cad_battery_basic): Not lithium-ion
#!extended @RECIPE (cad_battery_extended): It's pretty metal
#!ultradense @RECIPE (cad_battery_ultradense): Call 1-(800)-BATTERY

#colorizer icon:cad_colorizer_rainbow Colorizers
A $(thing)CAD Colorizer$(0) is an optional attachment to a $(thing)CAD$(0) that modifies the color of its user's $(thing)Psi energy$(0) as it manifests in the physical world.$(p)All $(thing)Colorizers$(0) are crafted with a base of an $(item)Iron Ingot$(0), a piece of $(item)Psidust$(0) on top, two pieces of $(item)Glass$(0) (one on either side), and of course a color item to apply in the center. 
A $(thing)Colorizer$(0) can be crafted with any of the sixteen vanilla $(item)Dyes$(0) for their respective colors.$(p)If $(item)Prismarine Crystals$(0) are used in place of a dye, the resulting $(thing)Colorizer$(0) will shift through the colors of the rainbow.$(p)If, on the other hand, $(o)no$() color item is used, the resulting $(thing)Colorizer$(0) will $(o)draw$() color $(o)out$() of the user's $(thing)Psi energy$(0), and the resulting particles will be nigh-invisible.
Finally, using another piece of $(item)Psidust$(0) in the $(thing)Colorizer$(0) seems to have no known effect for most people, though certain individuals have reported differently.$(p)A $(thing)Colorizer$(0) in a $(thing)CAD$(0) affects:$(p)$(li)particles emitted by the $(thing)CAD$(0);$(p)$(li)$(thing)Spell Circles$(0) cast;$(p)$(li)blocks and lights conjured by $(piece)Trick: Conjure Light$(0) and $(piece)Trick: Conjure Block$(0).
@RECIPES (colorizer): Taste the Rainbow


__END__
##items icon:spell_bullet Items

#Spell Bullet
//TODO

#Projectile Spell Bullet
//TODO

#Loopcast Spell Bullet
//TODO

#Circle Spell Bullet
//TODO

#Grenade Spell Bullet
//TODO

#Charge Spell Bullet
//TODO

#Mine Spell Bullet
//TODO

#Spell Detonator
//TODO

#Psimetal Exosuit
//TODO

#Exosuit Sensors
//TODO

#Psimetal Tools
//TODO

#Vector Ruler
//TODO

#Spell Drive
//TODO

##tricks icon:textures/spell/trick_explode.png Tricks


##operators icon:textures/spell/operator_sum.png Operators


##selectors icon:textures/spell/selector_caster.png Selectors & Etc

#The Basics
// TODO rehash Debug, Explode

#Numbers 101
Numbers are an essential component to Spell Programming. These are basic arithmetic operators that can be used for math in spells.$(p)If you don't have anything that uses numbers yet, try adding up two constants for a Debug trick.$(p)Make sure to take note the difference between "Number" and "Number Constant" when holding shift on any spell piece. A parameter that requires a "Number Constant" can't take a "Number", but a parameter that requires a "Number" can take a "Number" or a "Number Constant". //TODO cleanup

#Vectors 101
Vectors are an essential component to Spell Programming. Many vectorial operations here included are very elementary, such as sum or subtraction. The red piece of this set, "Operator: Vector Construct" creates a Vector given the X, Y and Z coordinates. Try using it with "Trick: Add Motion" to make a spell that makes you jump up.$(p)Regarding another complicated piece in this group: A Cross Product of two vectors is a vector that is perpendicular to both. You can make use of this to get a vector that goes to the player's side, by executing the Cross Product of the player's look vector and (0, 1, 0), which you can get with "Operator: Vector Construct". //TODO cleanup

#Entities 101
Entities are an essential component to Spell Programming. While using components like "Selector: Caster" it's possible to get the person casting the spell, the pieces included here allow for targeting other entities in the world.$(p)You can make use of the pieces here to create spells that affect other entities. Try using it with "Trick: Add Motion" on them instead of yourself. //TODO cleanup

#Alternative Casting
Aside from the standard Spell Bullets, alternate spell $(item)Bullets$(0) can be created, that allow for spells to be casted in different ways.$(p)Projectile Spell Bullets, instead of casting the spell straight away, emit a projectile, that casts the spell upon colliding with something. Grenade Spell Bullets function similarly to the Projectile ones, but create a "grenade" style projectile that is affected by gravity and explodes (casting the spell) after 3 seconds of being fired. Charge Spell Bullets work like the Grenade ones, but will only cast the spell when ignited by a Spell Detonator item. Mine Spell Bullets also work like the Grenade ones, and will cast the spell once an entity walks into them and walks out. Circle Spell Bullets create a Spell Circle where the caster is looking, the spell is cast on the position of the spell circle 20 times over the course of 5 seconds.$(p)The usage of alternative $(item)Bullets$(0) like these requires the introduction of the "Selector: Focal Point" piece, which selects the Focal Point of the spell. For normal Spell Bullets, the Focal Point is the player itself, whereas for Projectile (or any of the derivate) Spell Bullets, the Focal Point is the projectile entity. Naturally, for Circle Spell Bullets, the Focal Point will be the spell circle. "Selector: Caster" always remains unchanged.$(p)The 32 block limit on spells exists around the Focal Point, so these alternate spell $(item)Bullets$(0) allow for spell effects to happen farther away. Furthermore, a spell can always affect its Caster, even if the Caster is outside the 32 block radius of the Focal Point. The Spell Detonator item can only detonate charges in a 32 block radius.$(p)The other piece of the group, "Selector: Ruler Vector" is to be used with a Vector Ruler. This item allows you to define a vector in world. Hold shift and right-click a block to set the source and right-click another normally to set the destination. When you use the selector, it gets the vector you selected. In the case that you have multiple Vector Rulers on you, the first one is used, hotbar taking priority. //TODO cleanup

#Blockworks
Working with blocks is an essential skill. As blocks are aligned to a grid in the world, you can refer to a block's position via a vector, so knowledge of the vector concepts is rather important for understanding the contents of Blockworks.$(p)Two of the most basic pieces in this group are the "Place Block" and "Break Block" tricks. They take a vector and either place or break a block in the position specified. For the case of "Trick: Place Block", the block placed is the one to the right of the player's CAD, on the hotbar. Of course, one of those blocks is taken from the player's inventory. Knowing where to place or break a block is easy, as it can be done through "Operator: Vector Raycast".$(p)There is something we have to keep in mind, however. A standard implementation of "Operator: Vector Raycast" gives us the block the player is looking at, and we can't place a block there, as one already exists! To remedy that, we can combine our "Operator: Vector Raycast" with the new "Operator: Vector Axis Raycast" piece, which gives us a vector equivalent to the side of the block we're looking at, so if we're looking at the top of the block, it'll give us an axial vector (0, 1, 0). We can then sum that, using "Operator: Vector Sum" to the result of our raycast to get where to place our block!$(p)In a similar fashion, "Operator: Entity Axial Look" gets an axial vector equivalent to the axis the player is looking at. Think of the "Facing" value in your F3 menu. "Operator: Entity Axial Look" does something similar. Say "Facing" would say "east", then "Operator: Entity Axial Look" would get you a vector (1, 0, 0). This, unlike the "Facing" value also detects when you're looking up and down.$(p)The other two tricks available here are "Trick: Place Block Sequence" and "Trick: Break Block Sequence", the latter being the red piece for this group. These tricks break or place a line of blocks. Similarly to the standard break and place tricks, they require a position to start off, but they also require another Vector, "Target", that defines the line in which it should interact. So if "Target" is (0, 4, 0), it'll place or break 4 blocks up, starting from the value of "Position". The last component to these tricks is "Max", this is a number constant for the maximum amount of blocks the trick is allowed to break or place. Since the vector requirements aren't constant, this works as means of calculating the Potency and Cost of the trick. The higher you set it, the more the spell will cost.$(p)The last piece in this group is "Operator: Vector Project". Vector Projection is a somewhat complex topic, so this will only explain one of the potential uses for it, that being projecting a vector onto an axis. Imagine you want to make a spell that places blocks from your position in the world to the position you're looking at, but in a straight line aligned to the side of the block you're looking at (using "Operator: Vector Axis Raycast"). You start off by getting the vector that you want to place blocks on, for using "Trick: Place Block Sequence", but if you're diagonal to the block, you may get something like (3, 2, 4). That's not a straight line! We can use "Operator: Vector Project" to project that into the axis of the side you're looking at, say, (0, 0, 1). So our "Vector A" is (3, 2, 4) and our "Vector B" is (0, 0, 1). Applying the projection leaves us with (0, 0, 4). If our "Vector B", was, for example, (1, 0, 0), we'd get (3, 0, 0). For the case where an axial vector is used in B, Vector Projection strips any parts of A that are 0 in B. We can then do our straight line.$(p)As the red piece in this group is "Trick: Break Block Sequence", you won't need anything too crazy for the most part. Try making a spell that brings down an 8 block high column, so you can "treecapitate". //TODO cleanup

#Psimetal Infusion
Psimetal is an important component to creating Casting Assistance Devices with better Psi conduction. The "Trick: Infusion" piece executes a release of psionic energy similar to that of a cast with no $(item)Bullets$(0), except more concentrated and focused.$(p)The piece takes no parameters, and functions the exact same manner as infusing Redstone to create Psidust does. To infuse Psimetal, drop Gold Ingots around, and cast a spell with "Trick: Infuse".$(p)Psimetal can not only be used to create more powerful CAD components, but also to create Spell Drives. Spell Drives function as a method of storing and transporting spells between various Programmer blocks. To write a Spell onto a Spell Drive, simply hold shift and right-click it on the Spell Programmer. After the drive has a spell, doing the same thing will set the spell on the programmer instead. To remove the spell from the drive, hold shift and right-click into the air.$(p)Lastly, Spell Drives can be copied by placing an empty one and a written one together in a crafting grid. //TODO cleanup

#Movement Advances
Movement and transport is a topic already addressed via the usage of "Trick: Add Motion". This group includes pieces that improve on that concept.$(p)"Trick: Blink" is the red piece of this group, and all it does is simply teleport the target entity forwards in the direction they're looking with a set maximum distance. A negative value will teleport the entity backwards. "Trick: Mass Blink" does the same as "Trick: Blink", but focused on an Entity List, having all of them be affected by the trick.$(p)"Trick: Mass Add Motion" is self-explanatory; it's an Entity List version of "Trick: Add Motion", adding the same motion to every entity in the list.$(p)Lastly, "Trick: Mass Exodus" moves every entity in an Entity List to a given position, with the given speed. Negative speed will move them away. //TODO cleanup

#Loopcasting
Loopcasting is a style of magic defined by the usage of Loopcast Spell Bullets. When a spell is cast from a Loopcast Spell Bullet, it executes as if it were cast from a normal one, but also puts the player into a "loopcasting" state, where, until they unequip their CAD, will continuously cast the same spell at a rate of 4 times a second. The advantage of loopcasting is the fact that the initial cooldown to psi regeneration is only applied on the first spell in full. For each subsequent cast, the cooldown will be much shorter than usual, so, given a caster with a high enough level to sustain psi regeneration to cover the cost of a spell, said spell can be endlessly loopcasted.$(p)The red piece of this group is "Selector: Loopcast Index". This piece selects the amount of times a spell has been loopcasted. For the initial cast this will be 0, and will be incremented once for every subsequent loopcast. This can be used alongside "Operator: Modulus" and "Operator: Integer Division" to alter how the spell functions every time it's cast.$(p)"Operator: Integer Division" does exactly as it says on the tin, and executes division of the integer parts of the two numbers. "Operator: Modulus" calculates the remainder of the division of the integer parts of the two numbers. Using these pieces, it's possible to do things such as digging undergound bunkers in any given size.$(p)"Selector: Loopcast Index" also works with Circle Spell Bullets, returning the amount of times the spell has been cast by the spell circle, up to 20. //TODO cleanup

#Block Movement
The ability to move blocks isn't as important as the ability to break and place them, but under some cases can come in handy.$(p)The red piece of this group, "Trick: Move Block" takes a position for a block in the world and moves it given the target vector. The target vector must be axial, if it isn't, the trick will fail.$(p)The other piece, "Trick: Collapse Block", simply collapses a block as if it were sand or gravel.$(p)Both these tricks will fail on complex blocks (also known as Tile Entities) or blocks that can't be harvested with Silk Touch. //TODO cleanup

#Elemental Arts
What is a system that allows for manipulation of the world's properties if it didn't include some good old fashioned elemental themed magic?$(p)This group contains Tricks for the four elements. The red piece of this group is "Trick: Smite", which creates a lightning bolt at the position passed in. The other tricks also do things of the sort.$(p)The group also contains "Operator: Random", a piece that will generate a random number between 0 (inclusive) and the number passed in (exclusive). This can be used alongside Loopcast or Spell Circle spells in many ways. For example, one can create a spell that would use "Trick: Overgrow" to mass bone meal a plantation. //TODO cleanup

#Greater Infusion
The ability to infuse Diamonds into Psigems is very important in the progress of spellslinging. Using Psigems, stronger CAD components can be created. Similarly to "Trick: Infusion", "Trick: Greater Infusion" will infuse nearby Diamonds, turning them into Psigems.$(p)Furthermore, "Trick: Ebony And Ivory" will infuse Coal into an Ebony Substance and Nether Quartz into an Ivory Substance, both of which can be combined with a Psimetal Ingot to create the respective alloy. These alloys can later be used to create stronger CAD Assemblies. "Trick: Ebony And Ivory" can only be used while in the End. //TODO cleanup

#Tool Casting
Psimetal and Psigems can be crafted into a Toolset: Shovel, Pickaxe, Axe and Sword.$(p)These tools can be socketed with up to 3 Spell Bullets. When their relative action is executed, that being breaking a block for tools or attacking a mob for the sword, the selected spell is activated. The spell in a Psimetal tool is selected the same way as a CAD. A fourth slot is also shown in the radial menu in case one wants to disable the spells of the tool entirely. Psimetal tools will slowly regenerate and restore their damage using the player's Psi energy, in bursts, as long as the tool isn't the item currently in the player's hand.$(p)Spells in a tool aren't casted by the tool, but rather by the CAD, therefore, the limitations imposed by the CAD's stats still stand.$(p)This group introduces a few pieces that can be used in conjunction with the tools. The red piece of this group, "Selector: Block Broken" is meant to be used with tools, and gets you a vector respective to where you broke the block in the world. "Selector: Block Broken Side" gets the side in which you broke that block.$(p)Lastly "Selector: Attack Target" does exactly as it sounds, it gets you the entity you attacked with a sword when the spell is casted. It can also be used with Projectile Spell Bullets, to get the entity that the projectile collided against, if any. //TODO cleanup

#Positive Effects
The ability to apply effects to entities is a must of any magical spellbook worth its weight. Luckily, you are not making spells with a spellbook, but you can still apply effects anyway.$(p)All of the pieces in this group will apply the respective potion effect to the target entity, for the target time (in seconds). If the piece also has a Power parameter, that defines the level of the effect to apply.$(p)So, for example, "Trick: Speed" with Time 20 and Power 2 would apply a Speed II effect for 20 seconds to the target entity. //TODO cleanup

#Negative Effects
As to be expected, after Positive Effects come Negative Effects.$(p)There isn't much to say here, really. Everything in this group works exactly as expected. Have fun. //TODO cleanup

#Exosuit Casting
Naturally, the method of casting following a tool set would be an armor set. You can create the Psimetal Exosuit using... you guessed it, Psimetal, as well as some Psigems. All the armor pieces of the set can be socketed with $(item)Bullets$(0), similarly to the Psimetal tools. Each piece handles a given "event", such as taking damage, or jumping. Whenever that event happens, the spell in the selected bullet will be cast.$(p)The events are as follows:<br>\u00a7nHelmet\u00a7r: Sensor Based (read on).<br>\u00a7nChestplate\u00a7r: Player taking damage.<br>\u00a7nLeggings\u00a7r: Every tick.<br>\u00a7nBoots\u00a7r: Player jumping.$(p)The Helmet can have Exosuit Sensors attached to it, by combining the two items in a crafting grid. Only one sensor can be attached at a time. The sensor can be removed by placing the helmet back on the crafting grid. There's a few sensors, such as the Light sensor, that triggers when the player enters the darkness, or the Stress sensor, that triggers when the player reaches low HP. Check them out at your leisure.$(p)To control the exosuit, you need to create an Exosuit Controller. This item allows you to modify the selected $(item)Bullets$(0) in each piece directly from your hand. Simply use your typical bullet selection hotkey with it equipped to bring up a menu with the ability to change multiple slots. Use the left and right mouse buttons to select which item is being changed, it works as usual after that. You can also hold shift and right-click the Exosuit Controller to instantly disable all the effects of your armor.$(p)Moving on to the pieces. The group contains various selectors you can use to help your Exosuit casting. The red piece of the group is "Selector: Time". This returns the CAD's time, kind of like its "system clock", in ticks. It constantly increments. It can be useful if you want to make something that works differently depending on the time. You don't need an exosuit to use it.$(p)The other two pieces in the group, "Selector: Attacker" and "Selector: Damage Taken" are to be used with the Exosuit Chestplate. The first selects the entity that attacked you, and the second the amount of damage you took. //TODO cleanup

#Trigonometry
This group includes operators relevant to trigonometric functions. The red piece of this group: "Constant: Pi" is exactly what it says on the tin, a constant that gives you the value of Pi.$(p)The group includes elementary trigonometric operations: sin, cos, asin and acos. The latter two being the inverse operators of sin and cos, also known as "sin^-1" or "cos^-1".$(p)Lastly, "Operator: Vector Dot Product" gives you the Dot Product of two vectors, the product of the two vectors' magnitudes and the cosine of the angle between them. Using "Operator: Arc Cosine" on the result will allow you to get the angle between two vectors. //TODO cleanup

#Smeltery
The pieces included in this group are very simplistic in the way they function, as both revolve around the concept of smelting things into other things as if they were put in a furnace.<br>"Trick: Smelt Item" will smelt a dropped item (Entity) in the world into its smelted counterpart, one item at a time.$(p)"Trick: Smelt Block" will smelt a block in the world into its smelted version, provided it's also a block. So while Cobblestone may be turned into Stone, Wood can't be turned into Charcoal. //TODO cleanup

#Flow Control
Flow Control is a somewhat complex subject. All the pieces here included allow for a spell to function in wildly different manners from what was available in your arsenal before. However, understanding how to properly use these pieces requires knowledge of the very internals of the spellcasting system. There are a few basic rules to be taken in mind to properly understand these concepts:<br>1. Spells execute in the order that the arrows drawn in the Spell Programmer point towards.<br>2. Any given piece's value will only be evaulated once. Any further pieces that require its value will just get the value evaluated the first time. For example, 3 instances of "Trick: Debug" pointing to the same "Operator: Random" will all print out the same value, as the random output will only be evaluted once.<br>3. A piece will only be evaluated when another piece requires its value. These chains are triggered by the Trick pieces.<br>4. Tricks are always executed from left to right and top to bottom. Therefore, a Trick in the second row will always be executed after a trick in the first.$(p)With that in mind, let's start off with the red piece of this group, "Trick: Sleep". This piece causes the spell to delay any further execution for the amount of ticks passed in. Knowing the order in which tricks execute, thanks to rule 4, putting this in the right place shouldn't be too hard. For those unaware, a Tick is a 1/20 fraction of a second. So if you wish to delay further processing of a spell by half a second, you would use 10 as the "Time" parameter. "Trick: Sleep" does not add any Projection to your spell, but does add Potency.$(p)"Trick: Evaluate" is a trick that does absolutely nothing. Yes, you heard that right. This trick does nothing. It doesn't increment any stats on your spell either. Its only application is to make use of rule 2, and evaluate a value before a Sleep is executed, allowing you to, for example, get the position where an entity was, with "Selector: Entity Position", before the Sleep is applied, for a trick used after said Sleep.$(p)"Trick: Die" is a Flow Control piece in the proper sense of the term. It takes a simple Number parameter, and if that number lies between -1 (exclusive) and 1 (also exclusive) it'll stop the spell's execution right then and there. Any other values will have the spell continue as usual. This piece doesn't add Projection. A very simple way to put it to use is to utilize "Selector: Sneak Status", which convinentely gives you 0 if the caster is sneaking and 1 if they're not. Almost as if they were made to go together!$(p)"Constant: Wrapper" allows you to make use of Number type pieces for tricks that would otherwise require a Number Constant. As you should know by now, the constant value given to a trick allows for calculation of the various stats of the spell before you even cast it, this being the normal reason variable numbers can't be fed into a trick. "Constant: Wrapper" requires two numbers, a constant one and a normal one. The constant value given to the piece will be the one used for any statistical calculation, whereas the normal number will be the one used for when the spell is actually put into use. The normal number's value will be capped out at the value of the constant one during spell execution, to prevent any sort of tomfoolery. The normal number is also always converted to a positive or negative number, depending on the sign of the constant number, so that the signs of both numbers match. If the constant number is 0, the result of this evaluation is always 0, regardless of the value of the normal number. //TODO cleanup

#Block Conjuration
This group includes pieces that do exactly as advertised, they conjure blocks.$(p)The red piece of the group, "Trick: Conjure Block" creates a Conjured Block at the given position. A Conjured Block is a semi-transparent, physical block that can, optionally, if the "Time" parameter is specified, disappear from the world after a bit. If the "Time" parameter is used, it's specified in Ticks. For those unaware, a Tick is equivalent to 1/20th of a second, so if you want to make a block that disappears after half a second, set "Time" to 10 ticks.$(p)"Trick: Conjure Light" conjures a light source instead, one that can't be collided against. "Trick: Conjure Block Sequence" functions much like "Trick: Place Block Sequence", but creates Conjured Blocks instead. Both these pieces also include the very same "Time" parameter.$(p)The color of the Conjured Blocks created is equal to that of the Colorizer used in the CAD (or the default light blue in case none is present). Colorizers whose color changes, such as the Full-Spectrum colorizer will also reflect in the visuals of the Conjured Blocks. //TODO cleanup

#Eidos Manipulation
Eidos Spells allow for the caster to manipulate the space-time continuum in their favor.$(p)The red piece of this group, "Trick: Eidos Reversal" retraces the caster's steps, at double speed, for the amount of time (in seconds) specified. Only one Reversal may be active at a time, and after a Reversal is cast, the effect of any subsequent cast is only available until the point where the last one ended. Sneaking will stop an ongoing Reversal.$(p)The other trick piece of the group, "Trick: Eidos Anchor" creates an "anchor" effect on the caster. After the target amount of time (in seconds), the caster will be taken back to where their anchor was. Multiple casts of "Trick: Eidos Anchor" can be done, but only the last one will take effect.$(p)Lastly "Selector: Eidos Changelog" takes a single number parameter (let's call it n), and gives you the position in the n'th index of the Eidos Changelog starting from the end. In simpler terms, it gives you a vector equal to the position that the caster was n ticks ago. Remember that "Trick: Eidos Reversal" takes the caster back in the changelog, wiping out any info that would come after. "Trick: Eidos Anchor" does not modify the changelog. //TODO cleanup

#Detection & Focus
This group includes two types of pieces, as the title says: detection, and focus. The red piece of the group falls under the "focus" area, however, in order to understand it, the concept of Slot Focus must be introduced.$(p)An already known example of Slot Focus is the family of Place Block style tricks. These make use of the block directly to the right of your CAD. Slot Focus is the slot which tricks like these will use. It can be relative (to the position of your CAD) or absolute, can only be in the hotbar and goes from 1 to 9. By default, whenever a spell is cast, its value is "Relative 1", so it's 1 slot to the right of your CAD. If it was "Relative -1" it would be 1 slot to the left of your CAD. "Absolute 3" would be the third slot in your hotbar. It also loops around, so if you have your CAD on your last slot and the value is "Relative 1", it'll be your first slot.$(p)To set the focused slot, you can use "Trick: Switch Focus Slot", the red piece of this group. This takes one of 2 parameters. Both are optional and mutually exclusive, and if you don't define any, it'll set the focus to the default of "Relative 1". If you choose to set the "Position" parameter, it'll set an Absolute value, whereas the "Shift" parameter will set a Relative value. This allows you to, for example, build things with different blocks based on the circumstance. This trick only works for the current spell cast, and the focus will reset the next time a spell is cast (even if it's the same spell).$(p)The other two pieces in the group are set in the "detection" area. First, "Selector: Item Presence" takes an optional slot number (if not set it'll default to your Focused Slot), and returns the amount of items in that slot, 0 if it's empty, of course. Lastly, "Selector: Block Presence" takes a vector, to be used as coordinates in the world, and finds the block there, the value returned is 0 if there's no block or a replaceable block (like tall grass), 1 if it's a non-solid block and 2 if it's a solid block. //TODO cleanup

#Memory Management
This group introduces the ability for spells to harness Persistent Memory in one's CAD. A CAD can store Vector type values for use in future spellcasts. The amount of Vectors that can be stored is equal to the CAD's "Sockets" stat divided by 3, rounded down. This is refered to the amount of Memory Slots present in the CAD.$(p)The group includes two pieces, simple IO style pieces to read and write vectors to and from the memory. The red piece, "Trick: Save Vector" saves a vector to the target Memory Slot, whereas "Selector: Saved Vector" gets the vector saved in the Memory Slot defined by its only parameter. Memory Slots for these pieces start in 1, so a CAD with 3 memory slots would accept values 1, 2, and 3. Both pieces add Potency to the spell equivalent to the number of the slot used.$(p)One imperfection with these pieces is the fact that "Trick: Save Vector" "locks" the target Memory Slot when used, preventing any of the two pieces from interacting with that same Memory Slot in the current spell cast after it goes through, be that read or write. So if you need to read the value in the slot before you write something, make sure to keep the fundamental rules of Flow Control in mind, to make sure the read goes through before the write. //TODO cleanup

#Secondary Operators
As the name implies, this group includes mathematical operators that aren't quite as important as the "primary" ones, such as sum or subtract. This group is, really, just a mixed bag of all sorts of math or logic relates pieces that can be used to help with spell creation. We'll separate the pieces in two sets to make them easier to explain.$(p)The first set is related to powers. Including pieces like "Operator: Square", "Operator: Power", "Operator: Square Root" and even "Operator: Logarithm". Most of these operate in a pretty standard fashion, with not much to talk about, except "Operator: Logarithm". This piece, as the name implies, executes the logarithm of the number passed in. The piece takes an optional Base paramter, and will calculate the logarithm for that base. If no base is passed in, it'll default to base 10. There's also "Constant: e", if you feel like using that, for whatever reason.$(p)The second set is related to logic. It includes pieces that do rounding (to an integer), "Operator: Ceiling", "Operator: Floor" and "Operator Round", which respectively round up, round down and round depending on the fractional part of the number. It also includes "Operator: Min" and "Operator: Max". These are pretty simple. They, respectively, get the smallest number and the largest number between the various numbers passed in. //TODO cleanup
